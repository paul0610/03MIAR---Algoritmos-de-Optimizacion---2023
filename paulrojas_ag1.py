# -*- coding: utf-8 -*-
"""PaulRojas-AG1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rshrzSQR1qKx1CjSvUyrB7GU758NsXyg

Nombre: Paul Florencio Rojas Quispe  
https://colab.research.google.com/drive/1rshrzSQR1qKx1CjSvUyrB7GU758NsXyg?usp=sharing

https://github.com/paul0610/03MIAR---Algoritmos-de-Optimizacion---2023
"""

#Torres de Hanoi - Divide y venceras
################################################################################


################################################################
def Torres_Hanoi(N, desde, hasta):
  #N - Nº de fichas
  #desde - torre inicial
  #hasta - torre fina
  if N==1 :
    print("Lleva la ficha desde " + str(desde) + " hasta " + str(hasta))

  else:
    Torres_Hanoi(N-1, desde, 6-desde-hasta)
    print("Lleva la ficha desde " + str(desde) + " hasta " + str(hasta))
    Torres_Hanoi(N-1, 6-desde-hasta,  hasta)

Torres_Hanoi(5, 1, 3)
################################################################



#Cambio de monedas - Técnica voraz
################################################################################
SISTEMA = [11, 5 ,  1  ]
################################################################
def cambio_monedas(CANTIDAD,SISTEMA):
#....
  SOLUCION = [0]*len(SISTEMA)
  ValorAcumulado = 0

  for i,valor in enumerate(SISTEMA):
    monedas = (CANTIDAD-ValorAcumulado)//valor
    SOLUCION[i] = monedas
    ValorAcumulado = ValorAcumulado + monedas*valor

    if CANTIDAD == ValorAcumulado:
      return SOLUCION

  print("No es posible encontrar solucion")

cambio_monedas(15,SISTEMA)


################################################################



#N Reinas - Vuelta Atrás()
################################################################################

#Verifica que en la solución parcial no hay amenzas entre reinas
################################################################
def es_prometedora(SOLUCION,etapa):
################################################################
  #print(SOLUCION)
  #Si la solución tiene dos valores iguales no es valida => Dos reinas en la misma fila
  for i in range(etapa+1):
    #print("El valor " + str(SOLUCION[i]) + " está " +  str(SOLUCION.count(SOLUCION[i])) + " veces")
    if SOLUCION.count(SOLUCION[i]) > 1:
      return False

    #Verifica las diagonales
    for j in range(i+1, etapa +1 ):
      #print("Comprobando diagonal de " + str(i) + " y " + str(j))
      if abs(i-j) == abs(SOLUCION[i]-SOLUCION[j]) : return False
  return True

#Traduce la solución al tablero
################################################################
def escribe_solucion(S):
################################################################
  n = len(S)
  for x in range(n):
    print("")
    for i in range(n):
      if S[i] == x+1:
        print(" X " , end="")
      else:
        print(" - ", end="")



#Proceso principal de N-Reinas
################################################################
def reinas(N, solucion=[],etapa=0):
################################################################
### ....
  if len(solucion) == 0:         # [0,0,0...]
    solucion = [0 for i in range(N) ]

  for i in range(1, N+1):
    solucion[etapa] = i
    if es_prometedora(solucion, etapa):
      if etapa == N-1:
        print(solucion)
      else:
        reinas(N, solucion, etapa+1)
    else:
      None

  solucion[etapa] = 0

reinas(8,solucion=[],etapa=0)



# Problema: Encontrar los dos puntos más cercanos
import random
import numpy as np # import numpy package
import time
import matplotlib.pyplot as plt



def encontrar_puntos_cercanos(lista):
    min_dist = float('inf')
    punto1 = -1
    punto2 = -1

    for i in range(len(lista)):
        for j in range(i + 1, len(lista)):
            distancia = abs(lista[i] - lista[j])
            if distancia < min_dist:
                min_dist = distancia
                punto1 = lista[i]
                punto2 = lista[j]

    return punto1, punto2, min_dist

"""**1. PRIMER INTENTO POR FUERZA BRUTA**"""



LISTA_1D = random.sample(range(1, 10001), 1000)

puntoA, puntoB, distancia = encontrar_puntos_cercanos(LISTA_1D)

print(f"Los dos puntos más cercanos por fuerza bruta son {puntoA} y {puntoB} con una distancia de {distancia}.")

"""**1.1 CALCULANDO COMPLEJIDAD POR FUERZA BRUTA:**

El algoritmo de fuerza bruta para encontrar los dos puntos más cercanos en una lista unidimensional, la complejidad temporal, es O(n^2)
n es el número de elementos en la lista.

Se pude mejorar? : Sí, se pueden emplear técnicas más eficientes para mejorar la complejidad temporal del problema. Una de ellas es el algoritmo de "Divide y vencerás"

A continuación se muestra el cálculo de la complejidad donde mostrará como la gráfica resultante se aproxima a lo indicado por **Big-O complexity chart de O(n^2)**

"""

# Ajustando el código para generar listas aleatorias de diferentes tamaños y medir el tiempo de ejecución

# Tamaños de lista para probar, aumentando de manera cuadrática
tamanos_lista_cuadraticos = [n**2 for n in range(10, 31, 5)]  # Por ejemplo, 10^2, 15^2, 20^2, etc.
tiempos_ejecucion_cuadraticos = []

# Medir el tiempo de ejecución para cada tamaño de lista cuadrático
for tamano in tamanos_lista_cuadraticos:
    # Generar una lista aleatoria con elementos únicos para el tamaño actual
    lista_test = random.sample(range(1, tamano * 10), tamano)
    inicio = time.time()
    encontrar_puntos_cercanos(lista_test) #acá usamos la función que creamos para encontrar puntos cercanos
    fin = time.time()
    tiempos_ejecucion_cuadraticos.append(fin - inicio)

# Graficar los resultados
plt.plot(tamanos_lista_cuadraticos, tiempos_ejecucion_cuadraticos, marker='o')
plt.xlabel('Tamaño de la Lista (Cuadrático)')
plt.ylabel('Tiempo de Ejecución (segundos)')
plt.title('Tiempo de Ejecución del Algoritmo de Fuerza Bruta (Escalado Cuadrático)')
plt.grid(True)
plt.show()



"""**2. APLICANDO DIVIDE Y VENCERÁS**"""

# función para encontrar los dos puntos más cercanos con divide y vencerás
def encontrar_puntos_cercanos_divide_y_venceras(lista):
    # Ordenar la lista para que los puntos más cercanos estén adyacentes
    lista_ordenada = sorted(lista)

    # Inicializar variables para la distancia mínima y los puntos más cercanos
    min_dist = float('inf')
    punto1 = -1
    punto2 = -1

    # Iterar a través de la lista ordenada
    for i in range(len(lista_ordenada) - 1):
        distancia = abs(lista_ordenada[i] - lista_ordenada[i + 1])
        if distancia < min_dist:
            min_dist = distancia
            punto1 = lista_ordenada[i]
            punto2 = lista_ordenada[i + 1]

    return punto1, punto2, min_dist

# Crear una lista de 1000 números únicos entre 1 y 10000
LISTA_1D = random.sample(range(1, 10001), 1000)

# Encontrar los dos puntos más cercanos usando el algoritmo de divide y vencerás
punto1, punto2, distancia = encontrar_puntos_cercanos_divide_y_venceras(LISTA_1D)

print(f"punto 1 :  {punto1}" )
print(f"punto 2 :  {punto2}" )
print(f"distancia : {distancia}" )

"""**2.1 Medición y Gráfica del Coste Computacional**

Ordenar la lista: Esta es la parte más costosa del algoritmo. La función sorted en Python generalmente utiliza un algoritmo de ordenamiento eficiente como Timsort, que tiene una complejidad promedio y peor caso de
O(nlogn).

Búsqueda Lineal de Puntos Cercanos: Una vez ordenada la lista, el algoritmo realiza una sola pasada a través de ella para encontrar los dos puntos más cercanos. Esta operación tiene una complejidad de O(n).

La complejidad total del algoritmo es dominada por la parte de ordenamiento, resultando en una complejidad total de O(nlogn).

**Mejoras Posibles**

Dado que la complejidad ya es O(nlogn) debido al paso de ordenamiento, que es óptima para este tipo de algoritmos, no hay mucho espacio para mejorar la eficiencia general en términos de complejidad asintótica. Sin embargo, podrían realizarse optimizaciones en términos de la implementación práctica, como el uso de algoritmos de ordenamiento más eficientes en casos específicos o la optimización de la búsqueda lineal.

"""

import matplotlib.pyplot as plt
import time

def medir_tiempo_ejecucion(func, lista):
    inicio = time.time()
    func(lista)
    fin = time.time()
    return fin - inicio

# Tamaños de lista para probar, aumentando linealmente
tamanos_lista = [n for n in range(100, 2100, 200)]
tiempos_ejecucion = []

# Medir el tiempo de ejecución para cada tamaño de lista
for tamano in tamanos_lista:
    lista_test = random.sample(range(1, 10001), tamano)
    tiempo = medir_tiempo_ejecucion(encontrar_puntos_cercanos_divide_y_venceras, lista_test)
    tiempos_ejecucion.append(tiempo)

# Graficar los resultados
plt.plot(tamanos_lista, tiempos_ejecucion, marker='o')
plt.xlabel('Tamaño de la Lista')
plt.ylabel('Tiempo de Ejecución (segundos)')
plt.title('Tiempo de Ejecución del Algoritmo (Complejidad O(n log n))')
plt.grid(True)
plt.show()



"""**2.2. Extender el algoritmo a 2D:**"""

import math

def distancia_euclidiana(punto1, punto2):
    return math.sqrt((punto1[0] - punto2[0])**2 + (punto1[1] - punto2[1])**2)

def encontrar_puntos_cercanos_divide_y_venceras_2d(lista):
    # Ordenar la lista por la coordenada x
    lista_ordenada = sorted(lista, key=lambda x: x[0])

    # Función recursiva para encontrar los puntos más cercanos
    def encontrar_puntos_recursivo(lista_ordenada):
        n = len(lista_ordenada)
        if n <= 1:
            return float('inf'), None, None

        # Dividir la lista en dos mitades
        medio = n // 2
        dist_izq, punto1_izq, punto2_izq = encontrar_puntos_recursivo(lista_ordenada[:medio])
        dist_der, punto1_der, punto2_der = encontrar_puntos_recursivo(lista_ordenada[medio:])

        # Encontrar la distancia mínima entre las dos mitades
        dmin, p1, p2 = min((dist_izq, punto1_izq, punto2_izq), (dist_der, punto1_der, punto2_der), key=lambda x: x[0])

        # Verificar si hay puntos más cercanos que cruzan el punto medio
        puntos_cercanos_medio = [p for p in lista_ordenada if abs(p[0] - lista_ordenada[medio][0]) < dmin]

        # Ordenar por la coordenada y para reducir las comparaciones
        puntos_cercanos_medio.sort(key=lambda x: x[1])

        # Comparar puntos en la banda cercana al punto medio
        for i in range(len(puntos_cercanos_medio)):
            for j in range(i + 1, min(i + 7, len(puntos_cercanos_medio))):  # Limitar las comparaciones a 7 vecinos más cercanos
                d = distancia_euclidiana(puntos_cercanos_medio[i], puntos_cercanos_medio[j])
                if d < dmin:
                    dmin = d
                    p1, p2 = puntos_cercanos_medio[i], puntos_cercanos_medio[j]

        return dmin, p1, p2

    return encontrar_puntos_recursivo(lista_ordenada)

# Ejemplo de uso
LISTA_2D = [(random.randrange(1,10000), random.randrange(1,10000)) for x in range(1000)]
distancia, punto1, punto2  = encontrar_puntos_cercanos_divide_y_venceras_2d(LISTA_2D)

print(f"punto 1 :  {punto1}" )
print(f"punto 2 :  {punto2}" )
print(f"distancia : {distancia}" )



"""**2.3 Extender el algoritmo a 3D.**"""

def distancia_euclidiana_3d(punto1, punto2):
    return math.sqrt((punto1[0] - punto2[0])**2 + (punto1[1] - punto2[1])**2 + (punto1[2] - punto2[2])**2)

def encontrar_puntos_cercanos_3d(lista):
    # Ordenar la lista por la coordenada x
    lista_ordenada = sorted(lista, key=lambda x: x[0])

    # Función recursiva para encontrar los puntos más cercanos
    def encontrar_puntos_recursivo(lista_ordenada):
        n = len(lista_ordenada)
        if n <= 1:
            return float('inf'), None, None

        # Dividir la lista en dos mitades
        medio = n // 2
        dist_izq, punto1_izq, punto2_izq = encontrar_puntos_recursivo(lista_ordenada[:medio])
        dist_der, punto1_der, punto2_der = encontrar_puntos_recursivo(lista_ordenada[medio:])

        # Encontrar la distancia mínima entre las dos mitades
        dmin, p1, p2 = min((dist_izq, punto1_izq, punto2_izq), (dist_der, punto1_der, punto2_der), key=lambda x: x[0])

        # Verificar si hay puntos más cercanos que cruzan el punto medio
        puntos_cercanos_medio = [p for p in lista_ordenada if abs(p[0] - lista_ordenada[medio][0]) < dmin]

        # Ordenar por la coordenada y para reducir las comparaciones
        puntos_cercanos_medio.sort(key=lambda x: x[1])

        # Comparar puntos en la banda cercana al punto medio
        for i in range(len(puntos_cercanos_medio)):
            for j in range(i + 1, min(i + 7, len(puntos_cercanos_medio))):  # Limitar las comparaciones a 7 vecinos más cercanos
                d = distancia_euclidiana_3d(puntos_cercanos_medio[i], puntos_cercanos_medio[j])
                if d < dmin:
                    dmin = d
                    p1, p2 = puntos_cercanos_medio[i], puntos_cercanos_medio[j]

        return dmin, p1, p2

    return encontrar_puntos_recursivo(lista_ordenada)

# Ejemplo de uso
LISTA_3D = [(random.randrange(1,10000), random.randrange(1,10000), random.randrange(1,10000)) for x in range(1000)]
distancia, punto1, punto2 = encontrar_puntos_cercanos_3d(LISTA_3D)

print(f"punto 1 :  {punto1}" )
print(f"punto 2 :  {punto2}" )
print(f"distancia : {distancia}" )

"""**2.4 Buscar documentación sobre el problema**

https://iq.opengenus.org/closest-pair-of-points/


Shamos, Michael Ian; Hoey, Dan (1975): "Closest-point problems".


"""